from rest_framework import permissions
from rest_framework.decorators import action
# import responce
from rest_framework.response import Response
from rest_framework import status
from djoser.views import UserViewSet as DjoserUserViewSet
from drf_spectacular.utils import extend_schema
from users.serializers import CustomUserCreateSerializer,CustomUserUpdateSerializer,CustomPasswordResetConfirmSerializer,GoogleLoginSerializer
from users.models import CustomUser
from django.utils.translation import gettext_lazy as _
from social_core.exceptions import AuthForbidden
from rest_framework.views import APIView
from django.contrib.auth import get_user_model
import requests
# import http_200
from rest_framework.status import HTTP_200_OK
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView, TokenVerifyView
User=get_user_model()
class CustomUserViewSet(DjoserUserViewSet):
    queryset=CustomUser.objects.all()
    serializer_class = CustomUserCreateSerializer

    # me endpoints
    @extend_schema(
        tags=["me"],
        summary="GET the current authenticated user's profile",
        description="Endpoint to GET current authenticated user's profile",
        methods=["GET"],
    )
    @extend_schema(
        tags=["me"],
        summary="Update the current authenticated user's profile",
        description="Endpoint to Update current authenticated user's profile (full_name and email required).",
        request=CustomUserUpdateSerializer,
        methods=["PUT", "PATCH"],
    )
    @action(
        methods=['get', 'put', 'patch'],
        detail=False,
        permission_classes=[permissions.IsAuthenticated],
    )
    def me(self, request, *args, **kwargs):
        # Call the inherited me() method from DjoserUserViewSet
        return super().me(request, *args, **kwargs)


# Auth Operations endpoints

    # Override other Djoser endpoints and tag them under 'auth'
    @extend_schema(
        tags=["auth"],
        summary="List Registered Users",
        description="Endpoint to List registered users."
        )
    def list(self, request, *args, **kwargs):
        # List users (admin access)
        return super().list(request, *args, **kwargs)
    
    @extend_schema(
        tags=["auth"],
        summary="Create new user",
        description="Endpoint to create new user"
        )
    def create(self, request, *args, **kwargs):
        # Create a new user
        return super().create(request, *args, **kwargs)
    
    @extend_schema(tags=["auth"],summary="Get User Profile",description="Endpoint to get user profile.")
    def retrieve(self, request, *args, **kwargs):
        # Retrieve user profile by uuid
        return super().retrieve(request, *args, **kwargs)

    @extend_schema(
        tags=["auth"],
        summary="Update users profile",
        description="Endpoint to Update user profile full_name. NOTE: You need to provide email as well for this endpoint to work.",
        request=CustomUserUpdateSerializer,
        )
    def update(self, request, *args, **kwargs):
        self.serializer_class=CustomUserUpdateSerializer
        return super().update(request,*args,**kwargs)
    
    @extend_schema(
        tags=["auth"],
        summary="Endpoint to update user profile",
        description="Endpoint to Update user profile full_name.",
        request=CustomUserUpdateSerializer,
        )
    def partial_update(self, request, *args, **kwargs):
        # Partial update user profile (PATCH)
        self.serializer_class=CustomUserUpdateSerializer
        return super().partial_update(request,*args,**kwargs)

    @extend_schema(
        tags=["auth"],
        summary="Activate user account using `uid` and `token`",
        description="Endpoint to Activate User account using `uid` and `token` generated on register or using `/resend_activation/` resource.",
    )
    def activation(self, request, *args, **kwargs):
        return super().activation(request, *args, **kwargs)
    
    @extend_schema(
        tags=["auth"],
        summary="Generate and send activation `uid` and `token` for User account.",
        description="Endpoint to Generate and send activation `uid` and `token` for User account.",
    )
    def resend_activation(self, request, *args, **kwargs):
        return super().resend_activation(request, *args, **kwargs)

    @extend_schema(
        tags=["auth"],
        summary="send password reset email",
        description="Endpoint to Send password reset email using current user email",
    )
    def reset_password(self, request, *args, **kwargs):
        return super().reset_password(request, *args, **kwargs)

    @extend_schema(
        tags=["auth"],
        summary="Reset password using `uid` and `token`",
        description="Endpoint to Reset password using `uid` and `token` generated by `/reset_password/` resource for current authenticated user.",
        request=CustomPasswordResetConfirmSerializer,
        )
    def reset_password_confirm(self, request, *args, **kwargs):
        serializer = CustomPasswordResetConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({"detail": _("Password has been reset with the new password.")}, status=HTTP_200_OK)


    @extend_schema(
        tags=["auth"],
        summary="Change user password.",
        description="Endpoint to Change user password using current password.",
    )
    def set_password(self, request, *args, **kwargs):
        return super().set_password(request, *args, **kwargs)

    

# JWT api endpoints
@extend_schema(
    summary="Generate access and refresh tokens",
    description="Takes a set of user credentials and returns an access and refresh JSON web token pair.",
    tags=["jwt"],
)
class CustomTokenObtainPairView(TokenObtainPairView):
    pass

@extend_schema(
    summary="Refresh access token",
    description="Takes a valid refresh token and returns a new access token.",
    tags=["jwt"],
)
class CustomTokenRefreshView(TokenRefreshView):
    pass

@extend_schema(
    summary="Verify access token validity",
    description="Verifies if a given token is valid.",
    tags=["jwt"],
)
class CustomTokenVerifyView(TokenVerifyView):
    pass

@extend_schema(tags=["social"],
               summary="Log Users in with google",
               description="Endpoint to log users in using google.",
               request=GoogleLoginSerializer,
               )
class GoogleLoginView(APIView):
    serializer_class = GoogleLoginSerializer
    def post(self, request):
        # Use the serializer to validate the request data
        serializer = self.serializer_class(data=request.data)
        print(serializer.data)
        if serializer.is_valid():
            access_token = serializer.validated_data['access_token']
            code = serializer.validated_data['code']
            id_token = serializer.validated_data['id_token']

            # Verify the ID token
            user_info = self.verify_google_token(id_token)
            if 'error' in user_info:
                return Response({'error': 'Invalid ID token'}, status=status.HTTP_400_BAD_REQUEST)

            # Check if the user exists or create a new one
            email = user_info.get('email')
            user, created = User.objects.get_or_create(email=email, defaults={'username': email})

            if created:
                user.set_unusable_password()  # No password needed for social users
                user.save()

            # Optionally create or retrieve an auth token
            # Here, you can return a response with a token
            return Response({'token': 'your_generated_token', 'user': user.email}, status=status.HTTP_200_OK)

        # Return validation errors if the serializer is invalid
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def verify_google_token(self, id_token):
        # Verify the token with Google
        response = requests.get(f'https://oauth2.googleapis.com/tokeninfo?id_token={id_token}')
        return response.json()